using System;
using System.Collections.Generic;
using Isidore.Maths;

namespace Isidore.Render
{

    /// <summary>
    /// Enumeration of the different type of render rays based
    /// on how they are created
    /// </summary>
    public enum RayType
    {
        /// <summary>
        /// A primary ray is generated by a projector or direct call with a of rank 0
        /// </summary>
        Primary,
        /// <summary>
        /// A transmitted ray passes though a media and is created by a material class
        /// </summary>
        Transmitted,
        /// <summary>
        /// A reflected ray bounces off a surface and is created by a material class
        /// </summary>
        Reflected
    };

    /// <summary>
    /// Enumeration indicated the status of the ray
    /// </summary>
    public enum RayStatus
    {
        /// <summary>
        /// Indicated that the ray has not been addressed
        /// </summary>
        Open,
        /// <summary>
        /// Indicated that the ray has been propagated, but not processed
        /// </summary>
        Propagated,
        /// <summary>
        /// Indicates that the ray has been propagated, processed, 
        /// and is closed from further consideration
        /// </summary>
        Closed
    };

    /// <summary>
    /// Render Rays are one dimensional quantities that represent propagation
    /// through physical space.  This class inherits the
    /// Maths Ray class which is similar in function to Points and Vectors
    /// in that they are purely mathematical implementations.
    /// </summary>
    public class RenderRay: Maths.Ray, ICloneable
    {
        # region Fields & Properties

        /// <summary>
        /// Position, or rank, of the ray in the ray tree
        /// </summary>
        public int Rank = 0;

        /// <summary>
        /// Identifies the type of ray, based on how it was created
        /// (Primary=0, Transmitted=1, Reflected=2)
        /// </summary>
        protected internal RayType Type = 0;

        /// <summary>
        /// Flag for identifying a ray as "open", or not yet propagated
        /// </summary>
        public RayStatus Status = 0;

        /// <summary>
        /// Time of ray's creation
        /// </summary>
        public double Time = 0.0;       

        /// <summary>
        /// Physical properties list
        /// </summary>
        public Properties Properties { get; set; } // = new Properties();

        /// <summary>
        /// Intersection data
        /// </summary>
        public IntersectData IntersectData = null; //{ get; set; }

        /// <summary>
        /// Parent Ray
        /// </summary>
        public RenderRay ParentRay { get; set; }

        /// <summary>
        /// Minimum propagation distance required for a valid hit
        /// </summary>
        public double MinimumTravel = 1.0e-6;

        /// <summary>
        /// Maximum propagation distance required for a valid hit
        /// </summary>
        public double MaximumTravel = double.PositiveInfinity;

        ///// <summary>
        ///// Spawned children rays
        ///// </summary>
        //public RenderRays ChildrenRay { get; set; }

        # endregion Fields & Properties
        # region Constructors

        /// <summary>
        /// Ray constructor.  All inputs are referenced (Not deep copied).
        /// </summary>
        /// <param name="Origin"> Origin Point in space </param>
        /// <param name="Dir"> Projection vector </param>
        /// <param name="Time"> Initial projection time </param>
        /// <param name="Rank"> Ray Rank (position) in the ray tree </param>
        /// <param name="Type"> Type of ray (Primary, Transmitted, Reflected)</param>
        /// <param name="Properties"> Ray property list </param>
        /// <param name="IntersectData"> Ray intersection data </param>
        public RenderRay(Point Origin = null, Vector Dir = null, double 
            Time = 0.0, int Rank = 0, RayType Type = 0,
            Properties Properties = null, IntersectData IntersectData = null)
            : base(Origin,Dir)
        {
            this.Time = Time;
            this.Rank = Rank;
            this.Type = Type;
            this.Properties = Properties ?? new Properties();
            this.IntersectData = IntersectData ?? new IntersectData();
        }

        # endregion Constructors
        # region Methods

        /// <summary>
        /// Applies the transformation matrix to this ray.  The matrix is a member of Transform.
        /// </summary>
        /// <param name="trans"> Transform instance </param>
        /// <param name="inverse"> Switch for using the inverse transform </param>
        new public void Transform(Transform trans, bool inverse = false)
        {
            // Handles Origin and direction
            base.Transform(trans, inverse);

            //// Covers Render specific components (if they exist)
            //if (intersectData != null)
            //    intersectData.Transform(trans, inverse);
        }

        /// <summary>
        /// Applies the transformation matrix to a copy of this ray.  The matrix is a member of Transform.
        /// </summary>
        /// <param name="trans"> Transform instance </param>
        /// <param name="inverse"> Switch for using the inverse transform </param>
        /// <returns> A copy of this vector in M-space </returns>
        new public RenderRay CopyTransform(Transform trans, bool inverse = false)
        {
            RenderRay newRay = Clone();
            newRay.Transform(trans);
            return newRay;
        }

        /// <summary>
        /// Deep-copy (Non-referenced) clone
        /// </summary>
        /// <returns> Cloned copy </returns>
        new public RenderRay Clone()
        {
            return CloneImp();
        }

        /// <summary>
        /// Moves the origin point the specified distance along the direction vector
        /// </summary>
        /// <param name="distance"> Length to move the origin </param>
        /// <returns> The shifted render ray </returns>
        public RenderRay PropForward(double distance)
        {
            // Copies Ray
            RenderRay newRay = Clone();

            // Marches ray's origin
            newRay.Origin = Origin + (Point)(Dir * distance);

            return newRay;
        }

        /// <summary>
        /// Deep-copy (Non-referenced) clone casted as an object class
        /// </summary>
        /// <returns> Object class clone </returns>
        object ICloneable.Clone()
        {
            return CloneImp();
        }

        /// <summary>
        /// Clone implementation. Uses MemberwiseClone to clone, and 
        /// inheriting classes will implement the cloning of
        /// specific data types 
        /// </summary>
        /// <returns> Clone copy </returns>
        protected virtual RenderRay CloneImp()
        {
            // Shallow copy
            RenderRay newCopy = (RenderRay)MemberwiseClone();

            // Deep copy
            DeepCopyOverride(ref newCopy);

            return newCopy;
        }

        /// <summary>
        /// Implements deep copies of members that would
        /// otherwise be shallow copied.
        /// </summary>
        /// <param name="copy"> Clone copy </param>
        protected virtual void DeepCopyOverride(ref RenderRay copy)
        {
            // From Maths.Ray
            copy.Origin = Origin.Clone();
            copy.Dir = Dir.Clone();
            
            if (Properties != null)
                copy.Properties = Properties.Clone();
            
            copy.IntersectData = IntersectData.Clone();

            if (ParentRay != null)
                copy.ParentRay = ParentRay.Clone();
        }

        /// <summary>
        /// Checks for equivalence
        /// </summary>
        /// <param name="obj"> .NET object </param>
        /// <returns> Equivalence boolean </returns>
        public override bool Equals(object obj)
        {
            return base.Equals(obj);
        }

        /// <summary>
        /// Returns the object's hash code. Used with Dictionaries and Equals
        /// </summary>
        /// <returns> Object's hash code </returns>
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        # endregion Methods
    }

    /// <summary>
    /// List of RenderRays
    /// </summary>
    public class RenderRays : List<RenderRay>
    {
        /// <summary>
        /// Clones the list
        /// </summary>
        /// <returns> Clone of list </returns>
        public RenderRays Clone()
        {
            // Makes new list using the default constructor
            RenderRays nrays = new RenderRays();

            // Adds a clone of each list member
            ForEach(ray => nrays.Add(ray.Clone()));

            return nrays;
        }
    }
}
